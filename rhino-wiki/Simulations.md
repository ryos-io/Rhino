Simulation is a test entity which will be executed and it generates load according to the 
implementation provided in the test classes against instance under test, for instance,  a web 
service. As simulations are running, the metrics thereof collected and assessed. It contains a 
set of rules and the implementation how the load is generated. 

So as to create a new simulation entity, create a plain Java object with `@Simulation` annotation: 

```java
@Simulation(name = "Example Simulation")
public class PerformanceTestingExample {
}
```

The simulation above does nothing unless we add some scenarios to it. A scenario is a method 
annotated with `@Scenario` annotation and contains the implementation of the load generation. A simulation 
might have multiple scenarios defined which are run during testing, independently and parallel:

```java
@Simulation(name = "Example Simulation")
public class PerformanceTestingExample {

  @Scenario(name = "Hello World")
  public void testHelloWorld(Recorder recorder) {
    // hello world
  }

  @Scenario(name = "Health Check")
  public void testHealthCheck(Recorder recorder) {
    // healthcheck 
  }
}
```

The name of the simulation is important. In a performance testing project, it is very likely that 
you will have multiple simulations. Rhino does know which simulation is to be run, with the 
simulation name, so they must be unique. 

#### Recording metrics

While simulation is running and so the scenarios, respectively, the metrics will be collected by 
recorders. Each load generator scenario gets recorder instance passed, so the load metrics can be
 stored in the recorder. The following example scenario records the service response along with the 
 step name:
 
```java
  @Scenario(name = "Health")
  public void performHealth(Recorder recorder) {

    OAuthUserImpl authUser = null;
    if (user instanceof OAuthUserImpl) {
      authUser = (OAuthUserImpl) user;
    }

    final Client client = ClientBuilder.newClient();
    final Response response = client
        .target("https://your-service/server-status/health")
        .request()
        .header("X-Request-Id", "Rhino-" + uuid)
        .header("X-API-Key", "Your-Key")
        .get();

    recorder.record("Health API Call", response.getStatus());
  }
  
```

As simulations might have multiple scenarios, a scenario might comprise multiple steps that are 
run sequentially whereas multiple scenarios are run in parallel. After every load generative 
action/or step you may choose to record the metrics for that action. The values of the scenarios 
will be broken down in multiple charts on dashboards: 

```java
  @Scenario(name = "Health")
  public void performHealth(Recorder recorder) {

    OAuthUserImpl authUser = null;
    if (user instanceof OAuthUserImpl) {
      authUser = (OAuthUserImpl) user;
    }

    final Client client = ClientBuilder.newClient();
    final Response response1 = client
        .target("https://your-service/server-status/health")
        .request()
        .header("X-Request-Id", "Rhino-" + uuid)
        .header("X-API-Key", "Your-Key")
        .get();

    recorder.record("Health API Call", response1.getStatus());
    
        final Response response2 = client
            .target("https://your-service/server-status/version")
            .request()
            .header("X-Request-Id", "Rhino-" + uuid)
            .header("X-API-Key", "Your-Key")
            .get();
    
        recorder.record("Version API Call", response2.getStatus());
  }
````

#### Simulation logs

The simulation metrics gathered in recorders can be written into simulation log files as flat 
file format. So as to enable simulation logging, you need to add @Logging annotation to the class:

````java
@Simulation(name = "Server-Status Simulation")
@Logging(file = "/var/log/simulation.log", formatter = GatlingLogFormatter.class)
public class PerformanceTestingExample {
  
}
````

Formatter attribute specify the format of the log file you wanto to use. Rhino supports 
GatlingLogFormatter, too so that the Gatling simulation reports can be generated by using Gatling
 tooling. You can omit the formatter parameter to employ the default formatting, however, as of 
 version 1.1.9 there is no tool to generate graphical reports.  In addition, you can write your 
 own formatter by implementing the `LogFormatter` interface and develop your own tooling to create 
 simulation reports.